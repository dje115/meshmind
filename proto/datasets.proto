syntax = "proto3";
package meshmind.datasets;
import "common.proto";

// A data source found during discovery.
message DiscoveredSource {
  string source_id = 1;
  string connector_type = 2;
  string path_or_uri = 3;
  string display_name = 4;
  uint64 estimated_size_bytes = 5;
  uint32 estimated_tables = 6;
  meshmind.common.Timestamp discovered_at = 7;
  map<string, string> metadata = 8;
}

// Classification result for a single column.
enum ColumnClass {
  COLUMN_CLASS_UNSPECIFIED = 0;
  IDENTIFIER = 1;
  PII = 2;
  FINANCIAL = 3;
  OPERATIONAL = 4;
  FREE_TEXT = 5;
  TIMESTAMP_COL = 6;
  NUMERIC = 7;
  SECRET = 8;
  UNKNOWN = 9;
}

message ColumnClassification {
  string table_name = 1;
  string column_name = 2;
  string data_type = 3;
  ColumnClass classification = 4;
  meshmind.common.Sensitivity suggested_sensitivity = 5;
  float confidence = 6;
  string pattern_matched = 7;
  bool redact_by_default = 8;
}

// Full schema snapshot of a discovered source.
message SchemaSnapshot {
  string source_id = 1;
  string connector_type = 2;
  repeated TableSchema tables = 3;
  repeated ColumnClassification column_classifications = 4;
  meshmind.common.Timestamp inspected_at = 5;
  uint64 total_rows_estimate = 6;
}

message TableSchema {
  string table_name = 1;
  repeated ColumnDef columns = 2;
  uint64 row_count_estimate = 3;
  uint64 size_bytes_estimate = 4;
}

message ColumnDef {
  string name = 1;
  string data_type = 2;
  bool nullable = 3;
  bool is_primary_key = 4;
}

// Approved rules for ingestion/training from a source.
message SourceProfile {
  string profile_id = 1;
  string source_id = 2;
  string approved_by = 3;
  meshmind.common.Timestamp approved_at = 4;

  repeated TableRule table_rules = 5;
  RedactionPolicy redaction_policy = 6;
  RetentionPolicy retention_policy = 7;

  uint32 row_limit = 8;
  bool allow_raw_retention = 9;
  bool allow_training = 10;
  meshmind.common.Sensitivity max_sensitivity = 11;
}

message TableRule {
  string table_name = 1;
  bool allowed = 2;
  repeated string allowed_columns = 3;
  repeated string redacted_columns = 4;
  uint32 row_limit = 5;
  string where_clause = 6;
}

message RedactionPolicy {
  bool redact_pii = 1;
  bool redact_secrets = 2;
  repeated string additional_redact_columns = 3;
  string redaction_method = 4;
}

message RetentionPolicy {
  uint32 max_age_days = 1;
  uint64 max_size_bytes = 2;
  bool keep_raw = 3;
}

// Extended DatasetManifest with full provenance.
message DatasetManifest {
  string manifest_id = 1;
  meshmind.common.HashRef from_event_hash = 2;
  meshmind.common.HashRef to_event_hash = 3;
  repeated meshmind.common.HashRef cas_objects = 4;
  repeated string notes = 5;

  string source_id = 6;
  string connector_type = 7;
  string preset = 8;
  meshmind.common.HashRef schema_snapshot_ref = 9;
  repeated RedactionRule redaction_rules_applied = 10;
  DatasetStats stats = 11;
  meshmind.common.Timestamp created_at = 12;
}

message RedactionRule {
  string column_name = 1;
  string method = 2;
}

message DatasetStats {
  uint64 total_items = 1;
  uint64 total_bytes = 2;
  uint32 tables_included = 3;
  uint32 columns_included = 4;
  uint32 columns_redacted = 5;
}

// Ingestion checkpoint for resumable ingestion.
message IngestCheckpoint {
  string ingest_id = 1;
  string source_id = 2;
  string table_name = 3;
  uint64 last_row_offset = 4;
  meshmind.common.HashRef last_event_hash = 5;
  meshmind.common.Timestamp updated_at = 6;
}

// A batch of ingested items.
message IngestBatch {
  string ingest_id = 1;
  string table_name = 2;
  uint32 batch_index = 3;
  uint64 row_offset = 4;
  uint64 row_count = 5;
  repeated IngestItem items = 6;
}

message IngestItem {
  string entity_id = 1;
  meshmind.common.HashRef content_ref = 2;
  string item_type = 3;
  map<string, string> attributes = 4;
}
